name: NewAPI Daily Check-in

on:
  schedule:
    - cron: '0 0,12 * * *'  # 每天 2 次（UTC 0点和12点，即北京时间 8点和20点）

  workflow_dispatch:
    inputs:
      platform:
        description: '指定平台（留空运行全部）'
        required: false
      debug:
        description: '开启 Debug 模式（截图+详细日志）'
        required: false
        type: boolean
        default: false

jobs:
  checkin:
    runs-on: ubuntu-22.04
    permissions:
      actions: write
      contents: write
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      # 安装 uv
      - name: Install uv
        uses: astral-sh/setup-uv@v4
        with:
          version: "latest"
      
      # 设置 Python
      - name: Set up Python
        run: uv python install 3.12
      
      # 安装依赖
      - name: Install dependencies
        run: uv sync
      
      # 安装 Xvfb 虚拟显示（用于绕过 Cloudflare 的 headless 检测）
      - name: Install Xvfb and Chrome
        run: |
          sudo apt-get update
          sudo apt-get install -y xvfb google-chrome-stable
      
      # 安装 Patchright 浏览器（备用）
      - name: Install Patchright browsers
        run: uv run patchright install chromium
      
      # 恢复 Cookie 缓存（OAuth 成功后自动保存的 Cookie，下次直接用 Cookie+API 更快）
      - name: Restore cookie cache
        uses: actions/cache@v4
        with:
          path: |
            .newapi_cookies
            .newapi_accounts_override.json
          key: newapi-cookies-${{ github.run_id }}
          restore-keys: |
            newapi-cookies-
      
      # 执行签到（使用 xvfb-run 模拟显示器）
      - name: Execute multi-platform check-in
        env:
          # 浏览器引擎配置
          # nodriver: 不基于 WebDriver，直接使用 CDP，最难被检测（推荐）
          # drissionpage: 不基于 WebDriver，较难被 Cloudflare 检测
          # patchright: 反检测 Chromium（备用）
          BROWSER_ENGINE: nodriver
          BROWSER_HEADLESS: "false"
          DISPLAY: ":99"
          
          # Debug 模式（设置为 true 开启截图和详细日志）
          # DEBUG: "true"
          NEWAPI_DEBUG: ${{ github.event.inputs.debug || 'false' }}
          
          # LinuxDO 账户（必填 - 自动模式只需要这个！）
          # JSON 格式: [{"username": "email", "password": "pass", "name": "显示名"}]
          # 自动模式：只配这个，系统自动遍历所有站点 OAuth 签到，无需手动配置每个站点
          LINUXDO_ACCOUNTS: ${{ secrets.LINUXDO_ACCOUNTS }}
          
          # NewAPI 站点手动配置（可选 - 不配则自动模式）
          # 如果设置了，使用预配置的 Cookie 签到（更快，不需要浏览器）
          # 如果不设置，自动用 LINUXDO_ACCOUNTS 通过 OAuth 登录所有站点
          # JSON 格式: [{"name": "账号名", "provider": "站点ID", "cookies": {"session": "xxx"}, "api_user": "123"}]
          NEWAPI_ACCOUNTS: ${{ secrets.NEWAPI_ACCOUNTS }}
          
          # 兼容旧配置（如果设置了 ANYROUTER_ACCOUNTS 也会被读取）
          ANYROUTER_ACCOUNTS: ${{ secrets.ANYROUTER_ACCOUNTS }}
          
          # WONG 公益站配置
          WONG_ACCOUNTS: ${{ secrets.WONG_ACCOUNTS }}
          
          # 通知配置 - Email
          EMAIL_USER: ${{ secrets.EMAIL_USER }}
          EMAIL_PASS: ${{ secrets.EMAIL_PASS }}
          EMAIL_TO: ${{ secrets.EMAIL_TO }}
          EMAIL_SENDER: ${{ secrets.EMAIL_SENDER }}
          CUSTOM_SMTP_SERVER: ${{ secrets.CUSTOM_SMTP_SERVER }}
          
          # 通知配置 - Gotify
          GOTIFY_URL: ${{ secrets.GOTIFY_URL }}
          GOTIFY_TOKEN: ${{ secrets.GOTIFY_TOKEN }}
          GOTIFY_PRIORITY: ${{ secrets.GOTIFY_PRIORITY }}
          
          # 通知配置 - Server酱³
          SC3_PUSH_KEY: ${{ secrets.SC3_PUSH_KEY }}
          
          # 通知配置 - wxpush
          WXPUSH_URL: ${{ secrets.WXPUSH_URL }}
          WXPUSH_TOKEN: ${{ secrets.WXPUSH_TOKEN }}
          
          # 通知配置 - Telegram
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
          TELEGRAM_TOKEN: ${{ secrets.TELEGRAM_TOKEN }}
          TELEGRAM_USERID: ${{ secrets.TELEGRAM_USERID }}
          
          # 通知配置 - PushPlus
          PUSHPLUS_TOKEN: ${{ secrets.PUSHPLUS_TOKEN }}
          
          # 通知配置 - Server酱 (旧版)
          SERVERPUSHKEY: ${{ secrets.SERVERPUSHKEY }}
          
          # 通知配置 - 钉钉
          DINGDING_WEBHOOK: ${{ secrets.DINGDING_WEBHOOK }}
          
          # 通知配置 - 飞书
          FEISHU_WEBHOOK: ${{ secrets.FEISHU_WEBHOOK }}
          
          # 通知配置 - 企业微信
          WEIXIN_WEBHOOK: ${{ secrets.WEIXIN_WEBHOOK }}
          
          # 通知配置 - Bark
          BARK_KEY: ${{ secrets.BARK_KEY }}
          BARK_SERVER: ${{ secrets.BARK_SERVER }}
        run: |
          set -o pipefail
          # 使用 xvfb-run 启动，模拟显示器绕过 Cloudflare headless 检测
          # 只运行 newapi 签到，不运行 LinuxDO 浏览（浏览帖子用 linuxdo-browse.yml）
          if [ -n "${{ github.event.inputs.platform }}" ]; then
            xvfb-run --server-args="-screen 0 1920x1080x24" uv run python main.py --platform ${{ github.event.inputs.platform }} 2>&1 | tee run_newapi.log
          else
            xvfb-run --server-args="-screen 0 1920x1080x24" uv run python main.py --platform newapi 2>&1 | tee run_newapi.log
          fi

      - name: Append runtime summary
        if: always()
        run: |
          {
            echo "## NewAPI Runtime Summary"
            echo
            if grep -q "AUTO_OAUTH_SUMMARY:" run_newapi.log; then
              echo '```json'
              grep "AUTO_OAUTH_SUMMARY:" run_newapi.log | tail -n 1 | sed 's/.*AUTO_OAUTH_SUMMARY: //'
              echo '```'
            else
              echo "AUTO_OAUTH_SUMMARY not found."
            fi
            echo
            if [ -f scripts/chrome_extension/failed_sites.json ]; then
              echo "### Failed Sites Report"
              echo '```json'
              python - <<'PY'
import json
from pathlib import Path
p = Path("scripts/chrome_extension/failed_sites.json")
data = json.loads(p.read_text(encoding="utf-8"))
print(json.dumps({
    "generated_at": data.get("generated_at"),
    "failed_count": data.get("failed_count", 0),
    "sample": (data.get("failed_sites") or [])[:5],
}, ensure_ascii=False, indent=2))
PY
              echo '```'
            else
              echo "### Failed Sites Report"
              echo "failed_sites.json not found."
            fi
            echo
            echo "### Key Log Lines"
            grep -E "LDOH|站点可用性过滤|签到结束|OAuth 网络不可达|WinError 1225" run_newapi.log | tail -n 40 || true
          } >> "$GITHUB_STEP_SUMMARY"

      - name: Commit failed sites report for extension
        if: always()
        run: |
          if [ ! -f scripts/chrome_extension/failed_sites.json ]; then
            echo "failed_sites.json not found, skip commit."
            exit 0
          fi

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          git add scripts/chrome_extension/failed_sites.json
          if git diff --cached --quiet; then
            echo "No failed-sites changes to commit."
            exit 0
          fi

          git commit -m "chore: sync failed sites for chrome extension [skip ci]"
          git pull --rebase origin "${GITHUB_REF_NAME}" || true
          git push origin "HEAD:${GITHUB_REF_NAME}" || true

      - name: Upload runtime log
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: run-newapi-log
          path: run_newapi.log
          retention-days: 3
          if-no-files-found: ignore

      # 上传 Debug 截图（仅在 debug 模式下）
      - name: Upload debug screenshots
        if: ${{ github.event.inputs.debug == 'true' && always() }}
        uses: actions/upload-artifact@v4
        with:
          name: debug-screenshots
          path: debug_screenshots/
          retention-days: 3
          if-no-files-found: ignore

      # 清理旧的工作流运行记录
      - name: Delete workflow runs
        uses: Mattraks/delete-workflow-runs@v2
        with:
          token: ${{ github.token }}
          repository: ${{ github.repository }}
          retain_days: 10
          keep_minimum_runs: 6
